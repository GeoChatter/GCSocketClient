{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["// eslint-disable-next-line eslint-comments/disable-enable-pair\n/* eslint-disable @typescript-eslint/no-floating-promises */\nimport * as signalR from '@microsoft/signalr';\nimport { z } from \"zod\"\nimport { createErrorText, GuessState } from './helpers.js';\n\nimport { Color, Flag, Guess, StreamerSettings } from \"./types.js\"\n\n\ninterface Listeners {\n    onStreamerSettings?: (streamerSettings: z.infer<typeof StreamerSettings>) => any\n    onSuccessfulGuess?: () => any,\n    onFailedGuess?: (error: string, text?: string) => any,\n}\n\n// helper to allow sleeping \nconst sleep = (ms: number) => new Promise(r => setTimeout(r, ms));\n\nexport default class GCSignalRClient {\n    connection: signalR.HubConnection\n    private listeners?: Listeners\n    private _streamerCode?: string\n    private running = false\n\n\n    /**\n     * The constructor for the class. It is called when the class is instantiated.\n     * @param {string} url - The url of the signalR hub from GeoChatter.\n     * @param {string} [streamerCode] - The streamer code is the code that is used on the Server to send the Guess to the right client.\n     * @param {Listeners} [listeners] - Listeners trigger a callback that should handle the app state on /map or in the twitch extension for example when streamerSettings change.\n     */\n    constructor(url: string, streamerCode?: string, listeners?: Listeners) {\n        z.string().url().parse(url)\n        this.connection = new signalR.HubConnectionBuilder().withUrl(url, {}).build();\n        this._streamerCode = streamerCode\n        this.listeners = listeners\n        this.#start()\n    }\n\n    /**\n     * It sets the streamer code and logs in to the map.\n     * @param {string | undefined} streamerCode - The streamer code that you get from the streamer(used to be the bot name).\n     */\n    set streamerCode(streamerCode: string | undefined) {\n        if (!streamerCode) {\n            console.warn(\"no streamer code given\")\n        }\n        this._streamerCode = streamerCode\n        console.info(\"new streamer code\", streamerCode)\n        this.#logInToMap()\n    }\n\n    /**\n     * It returns the value of the private variable _streamerCode.\n     * @returns The streamerCode property is being returned.\n     */\n    get streamerCode(): (string | undefined) {\n        return this._streamerCode\n    }\n\n    /**\n     * It starts the connection, logs in to the map, listens to streamer settings it got back from the map login and listens to problems\n     */\n    async #start() {\n        if (this.running) {\n            console.warn(\"don't use start again! use reconnect instead\")\n        }\n        await this.connection.start()\n        this.#logInToMap()\n        this.#listenToStreamerSettings()\n        this.#listenToProblems()\n        this.running = true\n    }\n\n    /**\n     * It stops the connection to the SignalR hub.\n     */\n    async stop() {\n        await this.connection.stop()\n    }\n\n    /**\n     * It does not really set anything but it calls the onStreamerSettings listener.\n     * \n     * @param {StreamerSettings} [streamerSettings] - StreamerSettings is an object that contains the streamer settings.\n     */\n    #setStreamerSettings(streamerSettings?: z.infer<typeof StreamerSettings>) {\n        if (!streamerSettings) {\n            console.warn(\"did'nt receive streamer settings as response\")\n        }\n        else {\n            this.listeners?.onStreamerSettings?.(streamerSettings)\n        }\n    }\n\n    /**\n     * > The function `logInToMap` is a function that calls the `MapLogin` method on the\n     * server and then gets the streamer settings from the server as a response.\n     */\n    async #logInToMap() {\n        const streamerSettings = StreamerSettings.parse(await this.connection.invoke(\"MapLogin\", this.streamerCode))\n        this.#setStreamerSettings(streamerSettings)\n    }\n\n    /**\n     * > When the server sends a message called \"SetMapFeatures\", the client will call the\n     * #setStreamerSettings function with the data sent by the server so the listener will be run\n     */\n    #listenToStreamerSettings() {\n        this.connection.on(\"SetMapFeatures\", (streamerSettings: z.infer<typeof StreamerSettings>) => {\n            this.#setStreamerSettings(streamerSettings)\n        })\n    }\n    /**\n     * If the connection gets closed, it waits 1 second and tries to reconnect\n     * it also logs if signal r is reconnecting\n     */\n    #listenToProblems() {\n        this.connection.onreconnecting = (e) => {\n            console.info(\"default reconnecting from singalR\", e)\n        }\n        this.connection.onclose = (e) => {\n            console.warn(\"signalR connection closed trying to reconnect manually\", e)\n            setTimeout(() => { this.reconnect() }, 1000)\n        }\n    }\n\n    /**\n     * > This function is called when the connection to the server is lost and the client needs to\n     * reconnect\n     * \n     * It starts and logs into the map again and then listens to the streamer settings again but it does not recreate the listers because they are already created.\n     * (not sure if its true but i believe it is)\n     * \n     * \n     */\n    async reconnect() {\n        console.info(\"reconnecting...\")\n        if (!this.streamerCode) {\n            console.warn(\"calling reconnect without streamer code\")\n        }\n\n        await this.connection.start()\n        const streamerSettings = StreamerSettings.parse(await this.connection.invoke(\"MapLogin\", this.streamerCode))\n        this.#setStreamerSettings(streamerSettings)\n    }\n\n    /**\n     * It sends a guess to the server and waits for the server to process it\n     * @param {Guess} guess - Guess - The guess object that gets send to the server.\n     * @param [checkGuess=true] - if true, the client will wait for the server to process the guess and\n     * then call the onSuccessfulGuess or onFailedGuess listener.\n     * It retries as long as the state is not \"Submitted\" or the counter hits 50.\n     * If checkGuess is false, the client will not wait for the server to process the guess.\n     * Otherwise it will call either the onSuccessfulGuess or onFailedGuess listener.\n     */\n    async sendGuess(guess: z.infer<typeof Guess>, checkGuess = true): Promise<void> {\n        let guessId: (number | undefined)\n        if (this.connection.state !== \"Connected\") {\n            console.log(\"not connected trying to reconnect before sending guess\")\n            await this.reconnect().then(async () => {\n                console.log(\"sending guess after reconnect\")\n                guessId = await this.connection.invoke(\"SendGuessToClients\", guess)\n            })\n        } else {\n            guessId = await this.connection.invoke(\"SendGuessToClients\", guess)\n        }\n        if (!checkGuess) return\n        if (typeof guessId === \"number\") {\n            let state: GuessState = await this.#getGuessState(guessId)\n            // 50 might be to much\n            let counter = 50\n            while (state === \"Submitted\" || counter <= 0) {\n                state = await this.#getGuessState(guessId)\n                console.log(state)\n                await sleep(300)\n                counter = counter - 1\n            }\n            if (counter <= 0) {\n                console.warn(\"something went wrong while processing guess on client\")\n                this.listeners?.onFailedGuess?.(state, \"something went wrong while processing guess on client\")\n                return\n            }\n            if (state === \"Success\" || state === \"TempSuccess\") {\n                this.listeners?.onSuccessfulGuess?.()\n            } else {\n                this.listeners?.onFailedGuess?.(state, createErrorText(state))\n            }\n        }\n    }\n    /**\n     * Sends the flag data to the server including the the values from SendingBase from \"./types.ts\"\n     * @param {Flag} data - Flag - This is the data that will be sent to the server.\n     */\n    async sendFlag(data: z.infer<typeof Flag>) {\n        await this.connection.invoke(\"SendFlagToClients\", Flag.parse(data))\n    }\n\n    /**\n     * Sends the color data to the server including the the values from SendingBase from \"./types.ts\"\n     * @param {Flag} data - Flag - This is the data that will be sent to the server.\n     */\n    async sendColor(data: z.infer<typeof Color>) {\n        await this.connection.invoke(\"SendColorToClients\", Color.parse(data))\n    }\n\n    /**\n     * This function returns a `Promise<GuessState>` that resolves to the `GuessState` of the guess depending on the `GuessState` Value the guess is either a `Success` or an Error or still progressing\n     * @param {number} id - The id of the guess you want to get the state of.\n     * @returns GuessState\n     */\n    async #getGuessState(id: number): Promise<GuessState> {\n        return await this.connection.invoke(\"GetGuessState\", id)\n    }\n}\n"],
  "mappings": "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",
  "names": []
}

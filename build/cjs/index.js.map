{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["// eslint-disable-next-line eslint-comments/disable-enable-pair\n/* eslint-disable @typescript-eslint/no-floating-promises */\nimport * as signalR from '@microsoft/signalr';\nimport { z } from \"zod\"\n\nexport { z } from \"zod\"\n\ninterface Listeners {\n    onStreamerSettings?: (streamerSettings: z.infer<typeof StreamerSettings>) => any\n    onSuccessfulGuess?: () => any,\n    onFailedGuess?: (error: string, text?: string) => any,\n}\n\n// helper to allow sleeping \nconst sleep = (ms: number) => new Promise(r => setTimeout(r, ms));\n\nexport class GCSocketClient {\n    connection: signalR.HubConnection\n    private listeners?: Listeners\n    private _streamerCode: string\n    private running = false\n\n\n    /**\n     * The constructor for the class. It is called when the class is instantiated.\n     * @param {string} url - The url of the signalR hub from GeoChatter.\n     * @param {string} [streamerCode] - The streamer code is the code that is used on the Server to send the Guess to the right client.\n     * @param {Listeners} [listeners] - Listeners trigger a callback that should handle the app state on /map or in the twitch extension for example when streamerSettings change.\n     */\n    constructor(url: string, streamerCode: string, listeners?: Listeners) {\n        const result = z.string().url().safeParse(url)\n        if (result.success) {\n            this.connection = new signalR.HubConnectionBuilder().withUrl(result.data, {}).build();\n            this._streamerCode = streamerCode\n            this.listeners = listeners\n            this.#start()\n        }\n        else {\n            throw  result.error\n        }\n\n    }\n\n    /**\n     * It sets the streamer code and logs in to the map.\n     * @param {string | undefined} streamerCode - The streamer code that you get from the streamer(used to be the bot name).\n     */\n    set streamerCode(streamerCode: string) {\n        if (!streamerCode) {\n            console.warn(\"no streamer code given\")\n        }\n        this._streamerCode = streamerCode\n        console.info(\"new streamer code\", streamerCode)\n        this.#logInToMap()\n    }\n\n    /**\n     * It returns the value of the private variable _streamerCode.\n     * @returns The streamerCode property is being returned.\n     */\n    get streamerCode(): (string) {\n        return this._streamerCode\n    }\n\n    /**\n     * It starts the connection, logs in to the map, listens to streamer settings it got back from the map login and listens to problems\n     */\n    async #start() {\n        if (this.running) {\n            console.warn(\"don't use start again! use reconnect instead\")\n        }\n        await this.connection.start()\n        this.#logInToMap()\n        this.#listenToStreamerSettings()\n        this.#listenToProblems()\n        this.running = true\n    }\n\n    /**\n     * It stops the connection to the SignalR hub.\n     */\n    async stop() {\n        await this.connection.stop()\n    }\n\n    /**\n     * It does not really set anything but it calls the onStreamerSettings listener.\n     * \n     * @param {StreamerSettings} [streamerSettings] - StreamerSettings is an object that contains the streamer settings.\n     */\n    #setStreamerSettings(streamerSettings?: z.infer<typeof StreamerSettings>) {\n        if (!streamerSettings) {\n            console.warn(\"did'nt receive streamer settings as response\")\n        }\n        else {\n            this.listeners?.onStreamerSettings?.(streamerSettings)\n        }\n    }\n\n    /**\n     * > The function `logInToMap` is a function that calls the `MapLogin` method on the\n     * server and then gets the streamer settings from the server as a response.\n     */\n    async #logInToMap() {\n        const res: unknown = await this.connection.invoke(\"MapLogin\", this.streamerCode)\n        const streamerSettingsRes = StreamerSettings.safeParse(res)\n        if (streamerSettingsRes.success) {\n            this.#setStreamerSettings(streamerSettingsRes.data)\n        }\n        else {\n            console.error(\"map log in\" , streamerSettingsRes.error)\n            console.log(res)\n        }\n    }\n\n    /**\n     * > When the server sends a message called \"SetMapFeatures\", the client will call the\n     * #setStreamerSettings function with the data sent by the server so the listener will be run\n     */\n    #listenToStreamerSettings() {\n        this.connection.on(\"SetMapFeatures\", (streamerSettings: z.infer<typeof StreamerSettings>) => {\n            this.#setStreamerSettings(streamerSettings)\n        })\n    }\n    /**\n     * If the connection gets closed, it waits 1 second and tries to reconnect\n     * it also logs if signal r is reconnecting\n     */\n    #listenToProblems() {\n        this.connection.onreconnecting = (e) => {\n            console.info(\"default reconnecting from singalR\", e)\n        }\n        this.connection.onclose = (e) => {\n            console.warn(\"signalR connection closed trying to reconnect manually\", e)\n            setTimeout(() => { this.reconnect() }, 1000)\n        }\n    }\n\n    /**\n     * > This function is called when the connection to the server is lost and the client needs to\n     * reconnect\n     * \n     * It starts and logs into the map again and then listens to the streamer settings again but it does not recreate the listers because they are already created.\n     * (not sure if its true but i believe it is)\n     * \n     * \n     */\n    async reconnect() {\n        console.info(\"reconnecting...\")\n        if (!this.streamerCode) {\n            console.warn(\"calling reconnect without streamer code\")\n        }\n\n        await this.connection.start()\n        const res:unknown = await this.connection.invoke(\"MapLogin\", this.streamerCode)\n        const streamerSettingsRes = StreamerSettings.safeParse(res)\n        if (streamerSettingsRes.success) {\n            this.#setStreamerSettings(streamerSettingsRes.data)\n        } else {\n            console.error(\"got a weird response from map login check if you need to update gcsocketlibrary\",  streamerSettingsRes.error)\n            console.log(res)\n        }\n    }\n\n    /**\n     * It sends a guess to the server and waits for the server to process it\n     * @param {Guess} guess - Guess - The guess object that gets send to the server.\n     * @param [checkGuess=true] - if true, the client will wait for the server to process the guess and\n     * then call the onSuccessfulGuess or onFailedGuess listener.\n     * It retries as long as the state is not \"Submitted\" or the counter hits 50.\n     * If checkGuess is false, the client will not wait for the server to process the guess.\n     * Otherwise it will call either the onSuccessfulGuess or onFailedGuess listener.\n     */\n    async sendGuess(guess: z.infer<typeof Guess>, checkGuess = true): Promise<void> {\n        let guessId: (number | undefined)\n        if (this.connection.state !== \"Connected\") {\n            console.log(\"not connected trying to reconnect before sending guess\")\n            await this.reconnect().then(async () => {\n                console.log(\"sending guess after reconnect\")\n                guessId = await this.connection.invoke(\"SendGuessToClients\", guess)\n            })\n        } else {\n            guessId = await this.connection.invoke(\"SendGuessToClients\", guess)\n        }\n        if (!checkGuess) return\n        if (typeof guessId === \"number\") {\n            let state: GuessState = await this.#getGuessState(guessId)\n            // 50 might be to much\n            let counter = 50\n            while (state === \"Submitted\" || counter <= 0) {\n                state = await this.#getGuessState(guessId)\n                console.log(state)\n                await sleep(300)\n                counter = counter - 1\n            }\n            if (counter <= 0) {\n                console.warn(\"something went wrong while processing guess on client\")\n                this.listeners?.onFailedGuess?.(state, \"something went wrong while processing guess on client\")\n                return\n            }\n            if (state === \"Success\" || state === \"TempSuccess\") {\n                this.listeners?.onSuccessfulGuess?.()\n            } else {\n                this.listeners?.onFailedGuess?.(state, createErrorText(state))\n            }\n        }\n    }\n    /**\n     * Sends the flag data to the server including the the values from SendingBase from \"./types.ts\"\n     * @param {Flag} data - Flag - This is the data that will be sent to the server.\n     */\n    async sendFlag(data: z.infer<typeof Flag>) {\n        const flagParseRes = Flag.safeParse(data)\n        if (flagParseRes.success) {\n            await this.connection.invoke(\"SendFlagToClients\",)\n        } else {\n            console.error(flagParseRes.error)\n            console.log(data)\n        }\n    }\n\n    /**\n     * Sends the color data to the server including the the values from SendingBase from \"./types.ts\"\n     * @param {Flag} data - Flag - This is the data that will be sent to the server.\n     */\n    async sendColor(data: z.infer<typeof Color>) {\n        const ColorParseRes = Color.safeParse(data)\n        if (ColorParseRes.success) {\n            await this.connection.invoke(\"SendColorToClients\", ColorParseRes.data)\n        }\n        else {\n            console.error(ColorParseRes.error)\n            console.log(data)\n        }\n    }\n\n    /**\n     * This function returns a `Promise<GuessState>` that resolves to the `GuessState` of the guess depending on the `GuessState` Value the guess is either a `Success` or an Error or still progressing\n     * @param {number} id - The id of the guess you want to get the state of.\n     * @returns GuessState\n     */\n    async #getGuessState(id: number): Promise<GuessState> {\n        return await this.connection.invoke(\"GetGuessState\", id)\n    }\n}\n\n/**\n * It matches the Errors and creates a better string \n * I removed all successful results from it.\n * @param {GuessState} status - The status of the guess.\n * @returns A string\n */\nfunction createErrorText(status: GuessState): string {\n    switch (status) {\n        case GuessState.Banned:\n            {\n                return \"You are banned by the streamer and not allowed participate in any games.\";\n            }\n        case GuessState.BotNotFound:\n            {\n                return \"Bot not found\";\n            }\n        case GuessState.GuessedAlready:\n            {\n                return \"Already sent a guess for the round!\";\n            }\n        case GuessState.InvalidCoordinates:\n            {\n                return \"Invalid coordinates. Refresh the page.\";\n            }\n        case GuessState.NoGame:\n            {\n                return \"No ongoing game found, try again later.\";\n            }\n        case GuessState.NotFound:\n            {\n                return \"Invalid user data. Refresh the page.\"\n            }\n        case GuessState.SameCoordinates:\n            {\n                return \"Failed to send same guess back to back.\";\n            }\n        case GuessState.TooFast:\n            {\n                return \"Sending guesses too fast, try guessing again.\";\n            }\n        case GuessState.UndefinedError:\n            {\n                return \"Server error. Try guessing again.\";\n            }\n        case GuessState.Unknown:\n            {\n                return \"Invalid guess id. Refresh the page.\";\n            }\n        default:\n            {\n                return \"Something went wrong. Try guessing again.\";\n            }\n    }\n}\n\nconst enum GuessState {\n    /** State for recently submitted guess */\n    Submitted = \"Submitted\",\n    /** State for successfully registered guess */\n    Success = \"Success\",\n    /** State for guess not having any game to be sent to */\n    NoGame = \"NoGame\",\n    /** State for temporary guesses successfully registering */\n    TempSuccess = \"TempSuccess\",\n    /** State for invalid user data */\n    NotFound = \"NotFound\",\n    /** State for guess sent by a banned player */\n    Banned = \"Banned\",\n    /** State for multiguess not being allowed */\n    GuessedAlready = \"GuessedAlready\",\n    /** State for multiguess sent too often */\n    TooFast = \"TooFast\",\n    /** State for invalid guess coordinates */\n    InvalidCoordinates = \"InvalidCoordinates\",\n    /** State for sending same coordinates back to back */\n    SameCoordinates = \"SameCoordinates\",\n    /** State for internal error */\n    UndefinedError = \"UndefinedError\",\n    /** State for no game/bot found */\n    BotNotFound = \"BotNotFound\",\n    /** State for unknown guess id */\n    Unknown = \"Unknown\"\n}\n\nexport const SendingBase = z.object(\n    {\n        bot: z.string(),\n        tkn: z.string(),\n        id: z.string(),\n        name: z.string(),\n        sourcePlatform: z.enum([\"YouTube\", \"Twitch\"]),\n        display: z.string(),\n        pic: z.string(),\n    }\n)\n\nexport const Guess = SendingBase.extend({\n    lat: z.string(),\n    lng: z.string(),\n    isTemporary: z.boolean(),\n    isRandom: z.boolean(),\n});\n\n\nexport const Flag = SendingBase.extend({\n    flag: z.string()\n});\n\n\nexport const Color = SendingBase.extend({\n    color: z.string()\n});\n\n// TODO: add all settings and maybe with show option\nexport const StreamerSettings = z.object({\n    MapIdentifier: z.string(),\n    Streamer: z.string(),\n    // not sure\n    InstalledFlagPacks: z.array(z.string()),\n    // convert to enum later\n    GameMode: z.string(),\n    IsUSStreak: z.boolean(),\n    EnableTemporaryGuesses: z.boolean(),\n    ShowFlags: z.boolean(),\n    ShowStreamOverlay: z.boolean(),\n})\n"],
  "mappings": "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",
  "names": ["import_zod", "GuessState"]
}

{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["// eslint-disable-next-line eslint-comments/disable-enable-pair\n/* eslint-disable @typescript-eslint/no-floating-promises */\nimport * as signalR from '@microsoft/signalr';\nimport { z } from \"zod\"\n\nexport { z } from \"zod\"\n\ninterface Listeners {\n    onStreamerSettings?: (streamerSettings: z.infer<typeof MapOptions>) => any\n    onSuccessfulGuess?: () => any,\n    onFailedGuess?: (error: string, text?: string) => any,\n    onGameStart?: (mapGameSettings: z.infer<typeof MapGameSettings>) => any,\n    onRoundStart?: (mapRoundStart: z.infer<typeof MapRoundSettings>) => any,\n    onRoundEnd?: () => any,\n    onGameEnd?: () => any,\n    onGameExit?: () => any,\n}\n\n// helper to allow sleeping \nconst sleep = (ms: number) => new Promise(r => setTimeout(r, ms));\n\nexport class GCSocketClient {\n    connection: signalR.HubConnection\n    private listeners?: Listeners\n    private _streamerCode: string\n    private running = false\n\n\n    /**\n     * The constructor for the class. It is called when the class is instantiated.\n     * @param {string} url - The url of the signalR hub from GeoChatter.\n     * @param {string} [streamerCode] - The streamer code is the code that is used on the Server to send the Guess to the right client.\n     * @param {Listeners} [listeners] - Listeners trigger a callback that should handle the app state on /map or in the twitch extension for example when streamerSettings change.\n     */\n    constructor(url: string, streamerCode: string, listeners?: Listeners) {\n        const result = z.string().url().safeParse(url)\n        if (result.success) {\n            this.connection = new signalR.HubConnectionBuilder().withUrl(result.data, {}).build();\n            this._streamerCode = streamerCode\n            this.listeners = listeners\n            this.#start()\n        }\n        else {\n            throw result.error\n        }\n\n    }\n\n    /**\n     * It sets the streamer code and logs in to the map.\n     * @param {string | undefined} streamerCode - The streamer code that you get from the streamer(used to be the bot name).\n     */\n    set streamerCode(streamerCode: string) {\n        if (!streamerCode) {\n            console.warn(\"no streamer code given\")\n        }\n        this._streamerCode = streamerCode\n        console.info(\"new streamer code\", streamerCode)\n        this.#logInToMap()\n    }\n\n    /**\n     * It returns the value of the private variable _streamerCode.\n     * @returns The streamerCode property is being returned.\n     */\n    get streamerCode(): (string) {\n        return this._streamerCode\n    }\n\n    /**\n     * It starts the connection, logs in to the map, listens to streamer settings it got back from the map login and listens to problems\n     */\n    async #start() {\n        if (this.running) {\n            console.warn(\"don't use start again! use reconnect instead\")\n        }\n        await this.connection.start()\n        await this.#logInToMap()\n        this.#listenToStreamerSettings()\n        this.#listenToProblems()\n        this.#listenToGameStart()\n        this.#listenToRoundStart()\n        this.#listenToRoundEnd()\n        this.#listenToGameEnd()\n        this.#listenToGameExit()\n        this.running = true\n    }\n\n    /**\n     * It stops the connection to the SignalR hub.\n     */\n    async stop() {\n        await this.connection.stop()\n    }\n\n    /**\n     * It does not really set anything but it calls the onStreamerSettings listener.\n     * \n     * @param {StreamerSettings} [streamerSettings] - StreamerSettings is an object that contains the streamer settings.\n     */\n    #setStreamerSettings(streamerSettings?: z.infer<typeof MapOptions>) {\n        if (!streamerSettings) {\n            console.warn(\"did'nt receive streamer settings as response\")\n        }\n        else {\n            this.listeners?.onStreamerSettings?.(streamerSettings)\n        }\n    }\n\n    /**\n     * > The function `logInToMap` is a function that calls the `MapLogin` method on the\n     * server and then gets the streamer settings from the server as a response.\n     */\n    async #logInToMap() {\n        const res: unknown = await this.connection.invoke(\"MapLogin\", this.streamerCode)\n        const streamerSettingsRes = MapOptions.safeParse(res)\n        if (streamerSettingsRes.success) {\n            this.#setStreamerSettings(streamerSettingsRes.data)\n        }\n        else {\n            console.error(\"map log in\", streamerSettingsRes.error)\n            console.log(res)\n        }\n    }\n\n    /**\n     * > When the server sends a message called \"SetMapFeatures\", the client will call the\n     * #setStreamerSettings function with the data sent by the server so the listener will be run\n     */\n    #listenToStreamerSettings() {\n        this.connection.on(\"SetMapFeatures\", (streamerSettings: z.infer<typeof MapOptions>) => {\n            this.#setStreamerSettings(streamerSettings)\n        })\n    }\n    /**\n     * It listens to the server for a message called \"StartGame\" and when it receives it, it calls the\n     * onGameStart listener with `mapGameSettings`\n     */\n    #listenToGameStart() {\n        this.connection.on(\"StartGame\", (data: unknown) => {\n\n            const res = MapGameSettings.safeParse(data)\n            if (res.success) {\n                this.listeners?.onGameStart?.(res.data)\n            }\n            else {\n                console.error(\"game start\", res.error)\n            }\n        })\n    }\n\n    /**\n     * It listens to the `StartRound` event from the server and calls the `onRoundStart` listener with the\n     * data from the server\n     */\n    #listenToRoundStart() {\n        this.connection.on(\"StartRound\", (data: unknown) => {\n\n            const res = MapRoundSettings.safeParse(data)\n            if (res.success) {\n                this.listeners?.onRoundStart?.(res.data)\n            }\n            else {\n                console.error(\"round start\", res.error)\n            }\n        })\n    }\n    /**\n     * It listens to the server for the \"EndRound\" event, and when it receives it, it calls the onRoundEnd\n     * function in the listeners object\n     */\n    #listenToRoundEnd() {\n        this.connection.on(\"EndRound\", () => {\n\n            this.listeners?.onRoundEnd?.()\n\n        })\n    }\n    /**\n     * It listens for the \"EndGame\" event from the server, and when it receives it, it calls the\n     * onGameEnd listener\n     */\n    /**\n     * It listens to the server for the \"EndGame\" event, and when it receives it, it calls the onGameEnd\n     * listener\n     */\n    #listenToGameEnd() {\n        this.connection.on(\"EndGame\", () => {\n\n            this.listeners?.onGameEnd?.()\n\n        })\n    }\n    /**\n     *  When the server sends the `ExitGame` message, call it calls the `onGameExit` listener\n     */\n    #listenToGameExit() {\n        this.connection.on(\"ExitGame\", () => {\n\n            this.listeners?.onGameExit?.()\n\n        })\n    }\n\n\n\n\n    /**\n     * If the connection gets closed, it waits 1 second and tries to reconnect\n     * it also logs if signal r is reconnecting\n     */\n    #listenToProblems() {\n        this.connection.onreconnecting = (e) => {\n            console.info(\"default reconnecting from singalR\", e)\n        }\n        this.connection.onclose = (e) => {\n            console.warn(\"signalR connection closed trying to reconnect manually\", e)\n            setTimeout(() => { this.reconnect() }, 1000)\n        }\n    }\n\n    /**\n     * > This function is called when the connection to the server is lost and the client needs to\n     * reconnect\n     * \n     * It starts and logs into the map again and then listens to the streamer settings again but it does not recreate the listers because they are already created.\n     * (not sure if its true but i believe it is)\n     * \n     * \n     */\n    async reconnect() {\n        console.info(\"reconnecting...\")\n        if (!this.streamerCode) {\n            console.warn(\"calling reconnect without streamer code\")\n        }\n\n        await this.connection.start()\n        const res: unknown = await this.connection.invoke(\"MapLogin\", this.streamerCode)\n        const streamerSettingsRes = MapOptions.safeParse(res)\n        if (streamerSettingsRes.success) {\n            this.#setStreamerSettings(streamerSettingsRes.data)\n        } else {\n            console.error(\"got a weird response from map login check if you need to update gcsocketlibrary\", streamerSettingsRes.error)\n            console.log(res)\n        }\n    }\n\n    /**\n     * It sends a guess to the server and waits for the server to process it\n     * @param {Guess} guess - Guess - The guess object that gets send to the server.\n     * @param [checkGuess=true] - if true, the client will wait for the server to process the guess and\n     * then call the onSuccessfulGuess or onFailedGuess listener.\n     * It retries as long as the state is not \"Submitted\" or the counter hits 50.\n     * If checkGuess is false, the client will not wait for the server to process the guess.\n     * Otherwise it will call either the onSuccessfulGuess or onFailedGuess listener.\n     */\n    async sendGuess(guess: z.infer<typeof Guess>, checkGuess = true): Promise<void> {\n        let guessId: (number | undefined)\n        if (this.connection.state !== \"Connected\") {\n            console.log(\"not connected trying to reconnect before sending guess\")\n            await this.reconnect().then(async () => {\n                console.log(\"sending guess after reconnect\")\n                guessId = await this.connection.invoke(\"SendGuessToClients\", guess)\n            })\n        } else {\n            guessId = await this.connection.invoke(\"SendGuessToClients\", guess)\n        }\n        if (!checkGuess) return\n        if (typeof guessId === \"number\") {\n            let state: GuessState = await this.#getGuessState(guessId)\n            // 50 might be to much\n            let counter = 50\n            while (state === \"Submitted\" || counter <= 0) {\n                state = await this.#getGuessState(guessId)\n                console.log(state)\n                await sleep(300)\n                counter = counter - 1\n            }\n            if (counter <= 0) {\n                console.warn(\"something went wrong while processing guess on client\")\n                this.listeners?.onFailedGuess?.(state, \"something went wrong while processing guess on client\")\n                return\n            }\n            if (state === \"Success\" || state === \"TempSuccess\") {\n                this.listeners?.onSuccessfulGuess?.()\n            } else {\n                this.listeners?.onFailedGuess?.(state, createErrorText(state))\n            }\n        }\n    }\n    /**\n     * Sends the flag data to the server including the the values from SendingBase from \"./types.ts\"\n     * @param {Flag} data - Flag - This is the data that will be sent to the server.\n     */\n    async sendFlag(data: z.infer<typeof Flag>) {\n        const flagParseRes = Flag.safeParse(data)\n        if (flagParseRes.success) {\n            await this.connection.invoke(\"SendFlagToClients\", flagParseRes.data)\n        } else {\n            console.error(flagParseRes.error)\n            console.log(data)\n        }\n    }\n\n    /**\n     * Sends the color data to the server including the the values from SendingBase from \"./types.ts\"\n     * @param {Flag} data - Flag - This is the data that will be sent to the server.\n     */\n    async sendColor(data: z.infer<typeof Color>) {\n        const ColorParseRes = Color.safeParse(data)\n        if (ColorParseRes.success) {\n            await this.connection.invoke(\"SendColorToClients\", ColorParseRes.data)\n        }\n        else {\n            console.error(ColorParseRes.error)\n            console.log(data)\n        }\n    }\n\n    /**\n     * This function returns a `Promise<GuessState>` that resolves to the `GuessState` of the guess depending on the `GuessState` Value the guess is either a `Success` or an Error or still progressing\n     * @param {number} id - The id of the guess you want to get the state of.\n     * @returns GuessState\n     */\n    async #getGuessState(id: number): Promise<GuessState> {\n        return await this.connection.invoke(\"GetGuessState\", id)\n    }\n}\n\n/**\n * It matches the Errors and creates a better string \n * I removed all successful results from it.\n * @param {GuessState} status - The status of the guess.\n * @returns A string\n */\nfunction createErrorText(status: GuessState): string {\n    switch (status) {\n        case GuessState.Banned:\n            {\n                return \"You are banned by the streamer and not allowed participate in any games.\";\n            }\n        case GuessState.BotNotFound:\n            {\n                return \"Bot not found\";\n            }\n        case GuessState.GuessedAlready:\n            {\n                return \"Already sent a guess for the round!\";\n            }\n        case GuessState.InvalidCoordinates:\n            {\n                return \"Invalid coordinates. Refresh the page.\";\n            }\n        case GuessState.NoGame:\n            {\n                return \"No ongoing game found, try again later.\";\n            }\n        case GuessState.NotFound:\n            {\n                return \"Invalid user data. Refresh the page.\"\n            }\n        case GuessState.SameCoordinates:\n            {\n                return \"Failed to send same guess back to back.\";\n            }\n        case GuessState.TooFast:\n            {\n                return \"Sending guesses too fast, try guessing again.\";\n            }\n        case GuessState.UndefinedError:\n            {\n                return \"Server error. Try guessing again.\";\n            }\n        case GuessState.Unknown:\n            {\n                return \"Invalid guess id. Refresh the page.\";\n            }\n        default:\n            {\n                return \"Something went wrong. Try guessing again.\";\n            }\n    }\n}\n\nconst enum GuessState {\n    /** State for recently submitted guess */\n    Submitted = \"Submitted\",\n    /** State for successfully registered guess */\n    Success = \"Success\",\n    /** State for guess not having any game to be sent to */\n    NoGame = \"NoGame\",\n    /** State for temporary guesses successfully registering */\n    TempSuccess = \"TempSuccess\",\n    /** State for invalid user data */\n    NotFound = \"NotFound\",\n    /** State for guess sent by a banned player */\n    Banned = \"Banned\",\n    /** State for multiguess not being allowed */\n    GuessedAlready = \"GuessedAlready\",\n    /** State for multiguess sent too often */\n    TooFast = \"TooFast\",\n    /** State for invalid guess coordinates */\n    InvalidCoordinates = \"InvalidCoordinates\",\n    /** State for sending same coordinates back to back */\n    SameCoordinates = \"SameCoordinates\",\n    /** State for internal error */\n    UndefinedError = \"UndefinedError\",\n    /** State for no game/bot found */\n    BotNotFound = \"BotNotFound\",\n    /** State for unknown guess id */\n    Unknown = \"Unknown\"\n}\n\nexport const SendingBase = z.object(\n    {\n        bot: z.string(),\n        tkn: z.string(),\n        id: z.string(),\n        name: z.string(),\n        sourcePlatform: z.enum([\"YouTube\", \"Twitch\"]),\n        display: z.string(),\n        pic: z.string(),\n    }\n)\n\nexport const Guess = SendingBase.extend({\n    lat: z.string(),\n    lng: z.string(),\n    isTemporary: z.boolean(),\n    isRandom: z.boolean(),\n});\n\n\nexport const Flag = SendingBase.extend({\n    flag: z.string()\n});\n\n\nexport const Color = SendingBase.extend({\n    color: z.string()\n});\n\n// TODO: add all settings and maybe with show option\nexport const MapOptions = z.object({\n    mapIdentifier: z.string().optional(),\n    botname: z.string().optional(),\n    streamer: z.string(),\n    // not sure\n    installedFlagPacks: z.string(),\n    // convert to enum later\n    gameMode: z.string(),\n    isUSStreak: z.boolean(),\n    temporaryGuesses: z.boolean(),\n    showFlags: z.boolean(),\n    showBorders: z.boolean(),\n    showStreamOverlay: z.boolean(),\n})\n\n\nexport const MapGameSettings = z.object({\n    mapID: z.string(),\n    mapName: z.string(),\n    forbidMoving: z.boolean(),\n    forbidRotating: z.boolean(),\n    forbidZooming: z.boolean(),\n    gameMode: z.string(),\n    gameState: z.string(),\n    isStreak: z.boolean(),\n    isInfinite: z.boolean(),\n    timeLimit: z.number(),\n    streakType: z.string(),\n})\n\nexport const MapRoundResult = z.object({\n    displayName: z.string(),\n    userName: z.string(),\n    profilePicUrl: z.string().url(),\n    wasRandom: z.boolean(),\n    score: z.number(),\n    distance: z.number(),\n    timeTaken: z.number(),\n    streak: z.number(),\n    countryCode: z.string(),\n    exactCountryCode: z.string(),\n    guessCount: z.number(),\n    isStreamerResult: z.boolean(),\n    guessedBefore: z.boolean()\n})\nexport const MapRoundSettings = z.object({\n    roundNumber: z.number(),\n    isMultiGuess: z.boolean(),\n    startTime: z.string(),\n})"],
  "mappings": "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",
  "names": ["z", "GuessState"]
}
